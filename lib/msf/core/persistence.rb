# -*- coding: binary -*-

#
# A Persistence-exploitation module
#

# require 'msf/core/module'

class Msf::Persistence < Msf::Module

    include Msf::Auxiliary::Report
    include Msf::PostMixin # lots of overlap in functionality

    class Complete < RuntimeError; end

    class Failed < RuntimeError; end

    # file_dropper sets needs_cleanup to true to track exploits that upload files
    # some post modules also use file_dropper, so let's define it here
    attr_accessor :needs_cleanup

    def initialize(info = {})
      if info['Payload'] && info['Payload']['Compat']
        info['Compat'] = Hash.new if info['Compat'].nil?
        info['Compat']['Payload'] = Hash.new if info['Compat']['Payload'].nil?
        info['Compat']['Payload'].update(info['Payload']['Compat'])
      end

      m = replicant

      if m.actions.length > 0 && !m.action
        raise Msf::MissingActionError, "Please use: #{m.actions.collect { |e| e.name } * ', '}"
      end

      super(info)

      self.payload_info = info['Payload'] || {}
      self.targets = Rex::Transformer.transform(info['Targets'], Array, [ Target ], 'Targets')

      if info.key? 'DefaultTarget'
        self.default_target = info['DefaultTarget']
      else
        self.default_target = 0
        # Add an auto-target to the persistence if it doesn't have one
        # Finally, only add the target if there is a remote host option
        if info['Targets'] && info['Targets'].count > 1 && !has_auto_target?(info['Targets']) && (respond_to?(:rhost) && respond_to?(:auto_targeted_index))
          auto = ['Automatic', { 'AutoGenerated' => true }.merge(info['Targets'][default_target][1])]
          info['Targets'].unshift(auto)
        end
      end

      if info['Payload'] && info['Payload']['ActiveTimeout']
        self.active_timeout = info['Payload']['ActiveTimeout'].to_i
      end

      # register_options SESSION is imported from post_mixin.rb/Msf::PostMixin
    end

    def self.type
      Msf::MODULE_PERSISTENCE
    end

    def type
      Msf::MODULE_PERSISTENCE
    end

    def setup
    end

    #
    # Create an anonymous module not tied to a file.  Only useful for IRB.
    #
    def self.create(session)
      mod = new
      mod.instance_variable_set(:@session, session)
      # Have to override inspect because for whatever reason, +type+ is coming
      # from the wrong scope and i can't figure out how to fix it.
      mod.instance_eval do
        def inspect
          '#<Msf::Post anonymous>'
        end
      end
      mod.class.refname = 'anonymous'

      mod
    end

    # This method returns the ID of the Mdm::Session that the persistence module
    # is currently running against.
    #
    # @return [NilClass] if there is no database record for the session
    # @return [Integer] if there is a database record to get the id for
    def session_db_id
      if session.db_record
        session.db_record.id
      else
        nil
      end
    end

    #
    # Returns the target's platform, or the one assigned to the module itself.
    #
    def target_platform
      (target && target.platform) ? target.platform : platform
    end

    #
    # Returns the target's architecture, or the one assigned to the module
    # itself.
    #
    def target_arch
      if target && target.arch
        target.arch
      else
        (arch == []) ? nil : arch
      end
    end

    def normalize_platform_arch
      c_platform = (target && target.platform) ? target.platform : platform
      c_arch = if target && target.arch
                 target.arch
               else
                 (arch == []) ? nil : arch
               end
      c_arch ||= [ ARCH_X86 ]
      return c_platform, c_arch
    end

    # Returns whether the requested payload is compatible with the module
    #
    # @param [String] name The payload name
    # @param [TrueClass] Payload is compatible.
    # @param [FlaseClass] Payload is not compatible.
    def is_payload_compatible?(name)
      p = framework.payloads[name]

      pi = p.new

      # Are we compatible in terms of conventions and connections and
      # what not?
      return false if !compatible?(pi)

      # If the payload is privileged but the persistence does not give
      # privileged access, then fail it.
      return false if !privileged && pi.privileged

      return true
    end

    # Returns a list of compatible payloads based on platform, architecture,
    # and size requirements.
    def compatible_payloads
      payloads = []

      c_platform, c_arch = normalize_platform_arch

      framework.payloads.each_module(
        'Arch' => c_arch, 'Platform' => c_platform
      ) do |name, mod|
        payloads << [ name, mod ] if is_payload_compatible?(name)
      end

      return payloads
    end

    def run
      raise NotImplementedError
    end

    def cleanup
    end

    def fail_with(reason, msg = nil)
      raise Msf::Persistence::Failed, "#{reason}: #{msg}"
    end

    # def evasion_commands
    #   {}
    # end

    # we want to default to passive so that we can wait a long time for the payloads to call back
    def stance
      'passive'
    end

    # we want to default to passive so that we can wait a long time for the payloads to call back
    def passive?
      true
    end

    def aggressive?
      false
    end

    # Generates the encoded version of the supplied payload using the payload
    # requirements specific to this persistence module. The encoded instance is returned
    # to the caller. This method is exposed in the manner that it is such that passive
    # persistences and re-generate an encoded payload on the fly rather than having to use
    # the pre-generated one.
    def generate_payload(pinst = nil)
      # Set the encoded payload to the result of the encoding process
      self.payload = generate_single_payload(pinst)

      # Save the payload instance
      self.payload_instance = pinst || payload_instance

      return payload
    end

    #
    # This method generates a non-cached payload which is typically useful for
    # passive exploits that will have more than one client.
    #
    def generate_single_payload(pinst = nil, platform = nil, arch = nil, explicit_target = nil)
      explicit_target ||= target

      if explicit_target.nil?
        raise MissingTargetError, 'No target has been specified.',
              caller
      end

      # If a payload instance was supplied, use it, otherwise
      # use the active payload instance
      real_payload = pinst || payload_instance

      if real_payload.nil?
        raise MissingPayloadError, 'No payload has been selected.',
              caller
      end

      # If this is a generic payload, then we should specify the platform
      # and architecture so that it knows how to pass things on.
      if real_payload.is_a?(Msf::Payload::Generic)
        # Convert the architecture specified into an array.
        if arch and arch.is_a?(String)
          arch = [ arch ]
        end

        # Define the explicit platform and architecture information only if
        # it's been specified.
        if platform
          real_payload.explicit_platform = Msf::Module::PlatformList.transform(platform)
        end

        if arch
          real_payload.explicit_arch = arch
        end

        # Force it to reset so that it will find updated information.
        real_payload.reset
      end

      # Duplicate the exploit payload requirements
      reqs = payload_info.dup

      # Pass save register requirements to the NOP generator
      reqs['Space'] = payload_space(explicit_target)
      reqs['SaveRegisters'] = nop_save_registers(explicit_target)
      reqs['Prepend'] = payload_prepend(explicit_target)
      reqs['PrependEncoder'] = payload_prepend_encoder(explicit_target)
      reqs['BadChars'] = payload_badchars(explicit_target)
      reqs['Append'] = payload_append(explicit_target)
      reqs['AppendEncoder'] = payload_append_encoder(explicit_target)
      reqs['DisableNops'] = payload_disable_nops(explicit_target)
      reqs['MaxNops'] = payload_max_nops(explicit_target)
      reqs['MinNops'] = payload_min_nops(explicit_target)
      reqs['Encoder'] = datastore['ENCODER'] || payload_encoder(explicit_target)
      reqs['Nop'] = datastore['NOP'] || payload_nop(explicit_target)
      reqs['EncoderType'] = payload_encoder_type(explicit_target)
      reqs['EncoderOptions'] = payload_encoder_options(explicit_target)
      reqs['ExtendedOptions'] = payload_extended_options(explicit_target)
      reqs['Exploit'] = self

      # Pass along the encoder don't fall through flag
      reqs['EncoderDontFallThrough'] = datastore['EncoderDontFallThrough']

      # Incorporate any context encoding requirements that are needed
      define_context_encoding_reqs(reqs)

      # Call the encode begin routine.
      encode_begin(real_payload, reqs)

      # Generate the encoded payload.
      encoded = EncodedPayload.create(real_payload, reqs)

      # Call the encode end routine which is expected to return the actual
      # encoded payload instance.
      return encode_end(real_payload, reqs, encoded)
    end

    def define_context_encoding_reqs(reqs)
      return unless datastore['EnableContextEncoding']

      # At present, we don't support any automatic methods of obtaining
      # context information.  In the future, we might support obtaining
      # temporal information remotely.

      # Pass along the information specified in our evasion datastore as
      # encoder options
      reqs['EncoderOptions'] = {} if reqs['EncoderOptions'].nil?
      reqs['EncoderOptions']['EnableContextEncoding'] = datastore['EnableContextEncoding']
      reqs['EncoderOptions']['ContextInformationFile'] = datastore['ContextInformationFile']
    end

    def encode_begin(real_payload, reqs)
    end

    def encode_end(real_payload, reqs, encoded)
      encoded
    end

    def target
      if respond_to?(:auto_targeted_index) && auto_target?
        auto_idx = auto_targeted_index
        if auto_idx.present?
          datastore['TARGET'] = auto_idx
        else
          # If our inserted Automatic Target was selected but we failed to
          # find a suitable target, we just grab the original first target.
          datastore['TARGET'] = 1
        end
      end

      target_idx = target_index
      return target_idx ? targets[target_idx.to_i] : nil
    end

    def target_index
      target_idx = begin
        Integer(datastore['TARGET'])
      rescue StandardError
        datastore['TARGET']
      end

      default_idx = default_target || 0
      # Use the default target if one was not supplied.
      if target_idx.nil? && default_idx && default_idx >= 0
        target_idx = default_idx
      elsif target_idx.is_a?(String)
        target_idx = targets.index { |target| target.name == target_idx }
      end

      return target_idx ? target_idx.to_i : nil
    end

    def has_auto_target?(targets = [])
      target_names = targets.collect { |target| target.first }
      target_names.each do |target|
        return true if target =~ /Automatic/
      end
      return false
    end

    attr_accessor :default_target, :targets, :payload_info, :payload_instance, :payload

    attr_reader :payload_info
  end
end
